(in-package #:com.hexstreamsoft.bigname)

(defparameter *below-20* #("zéro" "un" "deux" "trois" "quatre" "cinq"
			 "six" "sept" "huit" "neuf"
			 "dix" "onze" "douze" "treize" "quatorze" "quinze"
			 "seize" "dix-sept" "dix-huit" "dix-neuf"))
(defparameter *tens* #("zéro" "dix" "vingt" "trente" "quarante" "cinquante" "soixante" "soixante-dix" "quatre-vingt" "quatre-vingt-dix"))
(defparameter *big-prefix* #("" "un" "duo" "tre" "quattuor" "quin" "sex" "septen" "octo" "novem"))
(defparameter *thousands* #("m" "b" "tr" "quatr" "quint" "sext" "sept"  "oct" "non"))
(defparameter *bof* #("dec" "vi" "tri" "quadra" "quinqua" "sexa" "septua" "octo" "nona"))

(defparameter *denominators* #("demi" "tiers" "quart"))

(defun ten-to-french (number stream)
  (cond ((> number 80)
	 (write-string (svref *tens* 8) stream)
	 (write-char #\- stream)
	 (number-to-french (- number 80) stream))
	((= number 80)
	 (write-string (svref *tens* 8) stream)
	 (write-char #\s stream))
	((> number 70)
	 (let ((rest (- number 70)))
	   (write-string (svref *tens* 6) stream)
	   (write-string (if (= rest 1)
			     " et "
			     "-")
			 stream)
	   (write-string (svref *below-20* (+ rest 10)) stream)))
	(t (multiple-value-bind (main rest) (floor number 10)
	     (write-string (svref *tens* main) stream)
	     (when (not (zerop rest))
	       (write-string (if (= rest 1)
				 " et "
				 "-")
			     stream)
	       (number-to-french rest stream))))))

(defun hundred-to-french (number stream)
  (multiple-value-bind (main rest) (floor number 100)
    (if (= main 1)
	(write-string "cent" stream)
	(progn (write-string (svref *below-20* main) stream)
	       (write-string " cent" stream)
	       (if (zerop rest)
		   (write-char #\s stream))))
    (when (not (zerop rest))
      (write-char #\Space stream)
      (number-to-french rest stream))))

(defun thousand-to-french (number stream)
  (multiple-value-bind (main rest) (floor number 1000)
    (when (> main 1)
      (number-to-french main stream)
      (write-char #\Space stream))
    (write-string "mille" stream)
    (when (not (zerop rest))
      (write-char #\Space stream)
      (number-to-french rest stream))))

(defun big-designation (zeroes stream)
  (let ((groups (floor zeroes 3)))
    (write-string (svref *thousands* (1- (floor groups 2))) stream)
    (write-string (if (evenp groups)
		      "illion"
		      "illiard")
		  stream)))

(defun big-to-french (number stream)
  (let* ((zeroes (floor (log number 10)))
	 (lion (expt 10 (* (floor zeroes 3) 3)))
	 (main (floor number lion))
	 (rest (- number (* main lion))))
    (number-to-french main stream)
    (write-char #\Space stream)
    (big-designation zeroes stream)
    (if (> main 1)
	(write-char #\s stream))
    (when (not (zerop rest))
      (write-char #\Space stream)
      (number-to-french rest stream))))

(defun number-to-french (number &optional stream)
  (with-output-to-string-or-stream (stream)
    (etypecase number
      (integer (cond ((< number 0)
		      (write-string "moins " stream)
		      (number-to-french (- number) stream))
		     ((< number 20)
		      (write-string (svref *below-20* number) stream))
		     ((< number 100)
		      (ten-to-french number stream))
		     ((< number 1000)
		      (hundred-to-french number stream))
		     ((< number 1000000)
		      (thousand-to-french number stream))
		     (t (big-to-french number stream))))
      (ratio (number-to-french (numerator number) stream)
	     (write-char #\Space stream)
	     (let ((denominator (denominator number)))
	       (if (<= denominator 4)
		   (write-string (svref *denominators* (- denominator 2)) stream)
		   (number-to-french-ordinal denominator stream)))))))

(defun number-to-french-ordinal (number &optional stream)
  (check-type number (integer 1))
  (with-output-to-string-or-stream (stream)
    (if (= number 1)
	(write-string "premier" stream)
	(if (= number 80)
	    (write-string "quatre-vingtième" stream)
	    (if (= number 81)
		(write-string "quatre-vingt et unième" stream)
		(let* ((base (number-to-french number))
		       (last-position (1- (length base)))
		       (last-character (char base last-position)))
		  (cond ((and (eql last-character #\f)
			      (= (mod number 10) 9))
			 (write-string base stream :end last-position)
			 (write-string "vième" stream))
			((and (eql last-character #\q)
			      (= (mod number 10) 5))
			 (write-string base stream)
			 (write-string "uième" stream))
			(t (write-string base stream
					 :end (if (eql last-character #\e)
						  last-position))
			   (write-string "ième" stream)))))))))